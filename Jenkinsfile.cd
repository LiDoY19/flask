#!/usr/bin/env groovy

pipeline {
    agent any

    environment {
        // Docker-related variables (point to the image produced by your CI pipeline)
        DOCKER_REPO             = "lidoy/gif_app_project"
        DOCKER_IMAGE_VERSION    = "gif_app_project:latest"
        
        // AWS-related variables
        AWS_REGION             = "us-east-1"
        EC2_INSTANCE_TAG_KEY   = "flaskapp"
        EC2_INSTANCE_TAG_VALUE = "flaskapp-test"

        // Azure-related variables
        AZURE_RESOURCE_GROUP   = "MyResourceGroup"
        AZURE_APP_SERVICE      = "MyAppService"
    }

    stages {
        stage('Checkout (Optional)') {
            steps {
                script {
                    // If you need to pull scripts/config from your repo for the deployment
                    // (e.g., a deploy script or configs), do so here.
                    // If not, you may remove this stage.
                    echo "Checking out repository (if needed for deployment scripts)..."
                    checkout scm
                }
            }
        }

        stage('Get EC2 Public IP') {
            steps {
                script {
                    echo "Fetching EC2 instance public IP via AWS CLI..."
                    withAWSCredentials {
                        env.EC2_PUBLIC_IP = fetchEC2PublicIP()
                        if (!env.EC2_PUBLIC_IP) {
                            error "No running EC2 instance found with tags '${EC2_INSTANCE_TAG_KEY}=${EC2_INSTANCE_TAG_VALUE}'. Aborting."
                        }
                        echo "EC2 Public IP: ${env.EC2_PUBLIC_IP}"
                    }
                }
            }
        }

        stage('Deploy to AWS EC2') {
            steps {
                script {
                    echo "Deploying Docker container to EC2 instance at ${env.EC2_PUBLIC_IP}..."
                    withSSHCredentials {
                        deployToEC2(env.EC2_PUBLIC_IP)
                    }
                    echo "Deployment to EC2 completed!"
                }
            }
        }

        stage('Deploy to Azure') {
            steps {
                script {
                    echo "Deploying Docker container to Azure App Service..."
                    withAzureCredentials {
                        deployToAzure()
                    }
                    echo "Deployment to Azure App Service completed!"
                }
            }
        }
    }

    post {
        success {
            echo "CD pipeline completed successfully!"
            // Optionally send notifications (Slack, email, etc.)
        }
        failure {
            echo "CD pipeline failed. Check logs for details."
            // Optionally send notifications (Slack, email, etc.)
        }
    }
}

/* -------------------------------------------------------------------------- */
/*                 Helper Methods & Credentials Wrappers                      */
/* -------------------------------------------------------------------------- */

/**
 * Wrap AWS credentials from Jenkins
 */
def withAWSCredentials(Closure body) {
    withCredentials([
        [$class: 'AmazonWebServicesCredentialsBinding', 
         credentialsId: 'AWS_CREDENTIALS'] // Replace with your AWS credential ID in Jenkins
    ]) {
        body()
    }
}

/**
 * Fetch the public IP of the EC2 instance by tag key/value.
 */
def fetchEC2PublicIP() {
    return sh(
        script: """
            set -e
            # Configure AWS CLI to use Jenkins-bound credentials
            aws configure set aws_access_key_id \$AWS_ACCESS_KEY_ID
            aws configure set aws_secret_access_key \$AWS_SECRET_ACCESS_KEY
            aws configure set default.region ${AWS_REGION}

            # Query EC2 for running instances with the specified tag
            aws ec2 describe-instances \\
                --filters "Name=tag:${EC2_INSTANCE_TAG_KEY},Values=${EC2_INSTANCE_TAG_VALUE}" \\
                          "Name=instance-state-name,Values=running" \\
                --query "Reservations[*].Instances[*].PublicIpAddress" \\
                --output text
        """,
        returnStdout: true
    ).trim()
}

/**
 * Wrap SSH private key credentials for SSH-based deployment to EC2.
 */
def withSSHCredentials(Closure body) {
    withCredentials([
        sshUserPrivateKey(
            credentialsId: 'aws_ssh_key',  // Replace with your Jenkins SSH key credential ID
            keyFileVariable: 'EC2_KEY_FILE',
            usernameVariable: 'EC2_USERNAME'
        )
    ]) {
        body()
    }
}

/**
 * Deploy to the EC2 instance using SSH and Docker commands.
 */
def deployToEC2(ec2PublicIp) {
    sh """
        set -e
        ssh -o StrictHostKeyChecking=no -i \$EC2_KEY_FILE \$EC2_USERNAME@${ec2PublicIp} << 'EOF'
            echo "Stopping any existing container named 'gif-app'..."
            docker stop gif-app || true
            docker rm gif-app || true

            echo "Pulling the Docker image..."
            docker pull ${DOCKER_REPO}:${DOCKER_IMAGE_VERSION}

            echo "Starting new container..."
            docker run -d --name gif-app -p 80:80 ${DOCKER_REPO}:${DOCKER_IMAGE_VERSION}
        EOF
    """
}

/**
 * Wrap Azure Service Principal credentials.
 */
def withAzureCredentials(Closure body) {
    withCredentials([
        azureServicePrincipal(
            credentialsId: 'AZURE_CREDENTIALS',  // Replace with your Azure credential ID
            subscriptionIdVariable: 'AZURE_SUBSCRIPTION_ID',
            clientIdVariable: 'AZURE_CLIENT_ID',
            clientSecretVariable: 'AZURE_CLIENT_SECRET',
            tenantIdVariable: 'AZURE_TENANT_ID'
        )
    ]) {
        body()
    }
}

/**
 * Deploy to Azure App Service using Azure CLI.
 */
def deployToAzure() {
    sh """
        set -e
        echo "Logging in to Azure CLI..."
        az login --service-principal -u \$AZURE_CLIENT_ID -p \$AZURE_CLIENT_SECRET --tenant \$AZURE_TENANT_ID >/dev/null

        echo "Configuring App Service to use container: ${DOCKER_REPO}:${DOCKER_IMAGE_VERSION}"
        az webapp config container set \\
            --name ${AZURE_APP_SERVICE} \\
            --resource-group ${AZURE_RESOURCE_GROUP} \\
            --docker-custom-image-name ${DOCKER_REPO}:${DOCKER_IMAGE_VERSION} \\
            --enable-cd true

        echo "Logout from Azure..."
        az logout
    """
}
